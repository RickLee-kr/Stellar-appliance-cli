#!/usr/bin/env python3
import os
import time
import subprocess
import logging
import secrets
import click
import hashlib
from filelock import FileLock, Timeout
from .log import get_logger, make_dir, ensure_file


class DiskEncryptUtil(object):
    DISK_ENCRYPT_FLAG = "# GENERATED BY AELLA_CLI/DISK_ENCRYPT"
    CRYPTTAB_FILE = '/etc/crypttab'
    RC_LOCAL_FILE = '/etc/rc.local'
    STELLAR_DATA_DEVICE = '/dev/mapper/stellar_data'
    WORKING_DIR = "/opt/aelladata/disk_encrypt"
    HEADER_BACKUP_COUNT = 100
    HEADER_BACKUP_DIR = "{}/headers".format(WORKING_DIR)
    LOCK_FILE = "{}/.lock".format(WORKING_DIR)
    LOCK = FileLock(LOCK_FILE)

    SERVICES = ("systemd-ask-password-wall.path", "systemd-ask-password-wall.service")

    @classmethod
    def ensure_lock(cls):
        return ensure_file(cls.LOCK_FILE, root=True)

    def __init__(self, logger):
        self.logger = logger

    def with_lock(self, callback, *args, **kwargs):
        timeout = 5
        try:
            with self.LOCK.acquire(timeout=timeout):
                callback(*args, **kwargs)
        except Timeout:
            print("Another instance of CLI currently holds the lock {}.".format(self.LOCK_FILE))
        except Exception as e:
            if "Permission denied" in str(e) or "No such file or directory" in str(e):
                self.ensure_lock()
                with self.LOCK.acquire(timeout=timeout):
                    callback(*args, **kwargs)
            else:
                raise

    @staticmethod
    def generate_passphrase(length=20):
        return secrets.token_hex(length)

    def print_log(self, msg, level=logging.INFO):
        print(msg)
        self.logger.log(level, msg.strip())

    def double_confirm(self):
        ans = input("\nAre you sure? (Type uppercase yes): ")
        if ans != "YES":
            self.print_log("The operation is abort.")
        return ans == "YES"

    @staticmethod
    def get_digest(content):
        if not isinstance(content, bytes):
            content = content.encode("utf-8")
        return hashlib.sha256(content).hexdigest()

    # crypttab
    def read_crypttab(self):
        self.logger.info("Read crypttab")
        proc = subprocess.Popen("sudo grep '{}' {}".format(self.DISK_ENCRYPT_FLAG, self.CRYPTTAB_FILE),
                                shell=True, stdout=subprocess.PIPE)
        out, _ = proc.communicate()
        if not out:
            return None, None
        # target_name, source_device
        return out.decode('utf-8').split()[:2]

    def update_crypttab(self, source_device, target_name, timeout=180):
        self.logger.info("Insert or update entry in crypttab")
        config_file = '/etc/crypttab'
        new_line = "{}\t{}\tnone\tluks,timeout={} {}".format(
            target_name, source_device, timeout, self.DISK_ENCRYPT_FLAG)

        # Update existing rule
        update_pattern = ' '.join(["-e 's%^.*{}.*%{}%g'".format(p, new_line) for p in (target_name, source_device)])
        proc = subprocess.Popen("sudo sed -i {} {}".format(update_pattern, config_file), shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to update {}'.format(config_file), level=logging.ERROR)

        # Insert new rule if it's not present
        create_pattern = ' '.join([
            "-e '/^[^#]*%s.*/{:a;n;ba;q}'" % p.replace('/', '\/')
            for p in (target_name, source_device)
        ])
        create_pattern += " -e '$a{}'".format(new_line)
        proc = subprocess.Popen("sudo sed -E -i {} {}".format(create_pattern, config_file), shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to update {}'.format(config_file), level=logging.ERROR)
        return proc.returncode == 0

    def remove_crypttab(self, source_device, target_name):
        self.logger.info("Remove entry in crypttab")
        config_file = '/etc/crypttab'
        update_pattern = ' '.join(["-e '/{}/d'".format(p.replace('/', '\/')) for p in (target_name, source_device)])
        proc = subprocess.Popen("sudo sed -i {} {}".format(update_pattern, config_file), shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to remove entries from {}'.format(config_file), level=logging.ERROR)
        return proc.returncode == 0

    # header
    def create_header_backup(self, source_device, backup_file):
        self.logger.info("Create header backup %s of device %s", backup_file, source_device)
        proc = subprocess.Popen("sudo cryptsetup luksHeaderBackup {} --header-backup-file {}".format(
            source_device, backup_file), shell=True)
        proc.communicate()
        return proc.returncode == 0

    def update_header_backups(self, source_device, digest, backup_dir=HEADER_BACKUP_DIR, count=HEADER_BACKUP_COUNT):
        self.logger.info("Update header backups")
        make_dir(backup_dir, root=True)
        backup_prefix = "header_backup_"
        backups = sorted([
            name for name in os.listdir(backup_dir)
            if os.path.basename(name).startswith(backup_prefix)
        ], reverse=True)
        self.logger.info("Find existing backups: %s", backups)
        # create backup
        result = self.create_header_backup(
            source_device, os.path.join(backup_dir, "{}{}_{}".format(backup_prefix, int(time.time()), digest)))
        while len(backups) > count:
            backup = backups.pop()
            self.logger.info("Delete backup %s", backup)
            proc = subprocess.Popen("sudo rm {}/{}".format(backup_dir, backup), stderr=subprocess.PIPE, shell=True)
            _, err = proc.communicate()
            if proc.returncode != 0:
                self.logger.error("Failed to delete backup %s: %s", backup, err.decode('utf-8'))
        return result

    # vm
    @staticmethod
    def get_vm_names(running=True, services=()):
        if not services:
            services = ("dl-master", "aio")
        services_str = "|".join(services)
        if running:
            cmd = "sudo virsh list |grep -E '%s' |grep 'running' |awk '{print $2}'" % services_str
        else:
            cmd = "sudo virsh list --all |grep -E '%s' |awk '{print $2}'" % services_str
        proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, shell=True)
        out, _ = proc.communicate()
        if out:
            return tuple(vm.strip() for vm in out.decode('utf-8').split())
        return ()

    def _shutdown_vm_with_command(self, command, vm, print_error=True):
        proc = subprocess.Popen("sudo virsh {} {}".format(command, vm), shell=True)
        proc.communicate()
        if proc.returncode != 0:
            if print_error:
                self.print_log("Failed to {} vm {}".format(command, vm), level=logging.ERROR)
            return False

        # wait for 5 min
        for i in range(30):
            running_vm_names = self.get_vm_names()
            if not running_vm_names:
                break
            if i == 0:
                print("Wait for 5 minutes at maximum")
            time.sleep(10)
            print("Still waiting... [{}s elapsed]".format((i + 1) * 10))

        running_vm_names = self.get_vm_names()
        if running_vm_names:
            if print_error:
                self.print_log("Failed to {} vm {}".format(command, running_vm_names), level=logging.ERROR)
            return False

        return True

    def shutdown_vm(self, vm, destroy=True, print_error=False):
        self.print_log("Shutdown vm {} gracefully".format(vm))
        if self._shutdown_vm_with_command("shutdown", vm, print_error=print_error):
            return True

        if destroy:
            self.print_log("Kill vm {}".format(vm))
            if self._shutdown_vm_with_command("destroy", vm):
                return True
        return False

    def destroy_vm(self, vm):
        self.print_log("Kill vm {}".format(vm))
        return self._shutdown_vm_with_command("destroy", vm)

    def start_vm(self, vm):
        self.print_log("Start vm {}".format(vm))
        proc = subprocess.Popen("sudo virsh start {}".format(vm), shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log("Failed to start vm {}".format(vm), level=logging.ERROR)
        return proc.returncode == 0

    # disk
    def format_disk(self, target_name):
        self.logger.info("Format disk %s as ext4", target_name)
        proc = subprocess.Popen("sudo mkfs.ext4 /dev/mapper/{}".format(target_name),
                                stderr=subprocess.PIPE, shell=True)
        _, err = proc.communicate()
        if proc.returncode != 0:
            self.print_log("Failed to format ext4 file system: {}".format(err.decode("utf-8")), level=logging.ERROR)
        return proc.returncode == 0

    @staticmethod
    def check_exists(file_path):
        proc = subprocess.Popen("sudo test -L {}".format(file_path), shell=True)
        proc.communicate()
        return proc.returncode == 0

    def ensure_open_encrypted_disk(self):
        target_name, source_device = self.read_crypttab()
        if not target_name:
            return True
        target_device = "/dev/mapper/{}".format(target_name)
        if not self.check_exists(target_device) and not self.open_encrypted_disk(source_device, target_name):
            return False
        return self._update_stellar_data_symlink(target_device, self.STELLAR_DATA_DEVICE)

    def ensure_close_encrypted_disk(self):
        target_name, _ = self.read_crypttab()
        if not target_name:
            return True
        target_device = "/dev/mapper/{}".format(target_name)
        if self.check_exists(target_device) and not self.close_encrypted_disk(target_name):
            return False
        return self._update_stellar_data_symlink(target_device, self.STELLAR_DATA_DEVICE)

    def open_encrypted_disk(self, source_device, target_name):
        self.logger.info("Open encrypted disk %s as %s", source_device, target_name)
        proc = subprocess.Popen("sudo cryptsetup open {} {}".format(source_device, target_name),
                                stderr=subprocess.PIPE, shell=True)
        _, err = proc.communicate()
        if proc.returncode != 0:
            self.print_log("Failed to open encrypted disk: {}".format(err.decode("utf-8")), level=logging.ERROR)
        return proc.returncode == 0

    def close_encrypted_disk(self, target_name, print_error=True):
        self.logger.info("Close encrypted disk %s", target_name)
        proc = subprocess.Popen("sudo cryptsetup close {}".format(target_name),
                                stderr=subprocess.PIPE, shell=True)
        _, err = proc.communicate()
        if proc.returncode != 0:
            if print_error:
                self.print_log("Failed to close encrypted disk", level=logging.ERROR)
            else:
                self.logger.error("Failed to close encrypted disk: %s", err.decode("utf-8"))
        return proc.returncode == 0

    def setup_disk_encryption(self, device, passwd):
        self.logger.info("Setup disk encryption")
        proc = subprocess.Popen(
            'echo -n {} |sudo cryptsetup luksFormat --use-random {} -'.format(passwd, device),
            stderr=subprocess.PIPE, shell=True)
        _, err = proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to enable disk encryption in {}: {}'.format(device, err.decode("utf-8")),
                           level=logging.ERROR)
        return proc.returncode == 0

    def validate_disk_encryption(self, device):
        self.logger.info("Validate disk encryption")
        proc = subprocess.Popen("sudo cryptsetup open {} --test-passphrase".format(device), shell=True,
                                stderr=subprocess.PIPE)
        _, err = proc.communicate()
        if err:
            self.logger.warn("validate disk encryption: %s", err.decode("utf-8"))
        return proc.returncode == 0

    # kernel modules
    def ensure_mod_dm_crypt(self):
        self.logger.info("Ensure kernel module: dm_crypt")
        proc = subprocess.Popen(
            "sudo sed -i -e '/^[^#]*dm_crypt.*/{:a;n;ba;q}' -e '$adm_crypt' /etc/modules", shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to add kernel module dm_crypt into /etc/modules', level=logging.ERROR)

        proc = subprocess.Popen("sudo modprobe dm_crypt", shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to add kernel module dm_crypt', level=logging.ERROR)
        return proc.returncode == 0

    def disable_systemd_services(self):
        for svc in self.SERVICES:
            self.logger.info("disable and stop {}".format(svc))
            proc = subprocess.Popen("sudo systemctl stop {}".format(svc), shell=True,
                                    stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
            _, err = proc.communicate()
            if proc.returncode != 0:
                self.logger.warn('Failed to stop unit %s: %s', svc, err.decode("utf-8"))
            else:
                self.logger.info('Stopped unit %s', svc)

            proc = subprocess.Popen("sudo systemctl mask {}".format(svc), shell=True,
                                    stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
            _, err = proc.communicate()
            if proc.returncode != 0:
                self.logger.warn('Failed to mask unit %s: %s', svc, err.decode("utf-8"))
            else:
                self.logger.info('Masked unit %s', svc)

    # symlink
    def _update_stellar_data_symlink(self, source_device, dest_device):
        self.logger.info("Update stellar_data symlink")
        proc = subprocess.Popen("sudo ln -sf {} {}".format(source_device, dest_device), shell=True)
        proc.communicate()
        return proc.returncode == 0

    def enable_encrypted_symlink(self, target_name):
        source_device = '/dev/mapper/{}'.format(target_name)
        if not self._update_stellar_data_symlink(source_device, self.STELLAR_DATA_DEVICE):
            self.print_log("Failed to create data symlink to {}".format(source_device), level=logging.ERROR)
            return False
        return self.update_rc_local()

    def disable_encrypted_symlink(self, target_name):
        source_device = '/dev/mapper/{}'.format(target_name)
        if not self._update_stellar_data_symlink(source_device, self.STELLAR_DATA_DEVICE):
            self.print_log("Failed to create data symlink to {}".format(source_device), level=logging.ERROR)
            return False
        return self.update_rc_local()

    def ensure_stellar_data_symlink(self):
        target_name, _ = self.read_crypttab()
        if not target_name:
            target_name = "vg_dl-lv_dl"
        original_device = '/dev/mapper/{}'.format(target_name)
        if not self._update_stellar_data_symlink(original_device, self.STELLAR_DATA_DEVICE):
            self.logger.error("Failed to create data symlink to {}".format(original_device), level=logging.ERROR)

    def update_rc_local(self):
        self.logger.info("Insert or update entry in rc.local")
        new_line = "/usr/local/bin/aella_cli_disk_encrypt --mode=bootstrap {}".format(
            self.DISK_ENCRYPT_FLAG).replace('/', '\/')
        escaped_flag = self.DISK_ENCRYPT_FLAG.replace('/', '\/')

        # Update existing rule
        update_pattern = "-e 's/^.*{}.*/{}/g'".format(escaped_flag, new_line)
        proc = subprocess.Popen("sudo sed -i {} {}".format(update_pattern, self.RC_LOCAL_FILE), shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to update {}'.format(self.RC_LOCAL_FILE), level=logging.ERROR)

        # Insert new rule if it's not present
        create_pattern = "-e '/^.*%s.*/{:a;n;ba;q}'" % escaped_flag  # If flag is found, don't insert before exit
        create_pattern += " -e '/^exit 0/i {}'".format(new_line)
        create_pattern += " -e '/^exit 0/{:b;n;bb;q}'"  # If exit is found, don't append
        create_pattern += " -e '$a{}'".format(new_line)
        proc = subprocess.Popen("sudo sed -E -i {} {}".format(create_pattern, self.RC_LOCAL_FILE), shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to update {}'.format(self.RC_LOCAL_FILE), level=logging.ERROR)
        return proc.returncode == 0

    def remove_rc_local(self):
        self.logger.info("Remove entry in rc.local")
        disk_encrypt_flag = self.DISK_ENCRYPT_FLAG.replace('/', '\/')
        update_pattern = "-e '/{}/d'".format(disk_encrypt_flag)
        proc = subprocess.Popen("sudo sed -i {} {}".format(update_pattern, self.RC_LOCAL_FILE), shell=True)
        proc.communicate()
        if proc.returncode != 0:
            self.print_log('Failed to remove entries from {}'.format(self.RC_LOCAL_FILE), level=logging.ERROR)
        return proc.returncode == 0

    # cryptsetup
    def get_available_key_slots(self, source_device):
        proc = subprocess.Popen(
            "sudo cryptsetup luksDump {} |grep -E 'Key Slot [0-9]+: DISABLED' |wc -l".format(source_device),
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
        out, err = proc.communicate()
        if proc.returncode != 0:
            self.print_log("Failed to check available key slots: {}".format(err.decode("utf-8")), level=logging.ERROR)
            return -1
        try:
            return int(out.decode("utf-8"))
        except ValueError:
            print("Failed to check available key slots.")
            self.logger.error("Failed to check available key slots", exc_info=1)
            return -1

    def is_last_key(self, source_device):
        return self.get_available_key_slots(source_device) >= 7


@click.command()
@click.option('--mode', type=click.Choice(['bootstrap', 'enable', 'disable']), help='Runtime mode.')
def main(mode):
    """Simple program that manage disk encryption."""
    logger = get_logger("aella_cli_disk_encrypt")
    util = DiskEncryptUtil(logger)

    if mode == "bootstrap":
        util.ensure_stellar_data_symlink()
    elif mode == "enable":
        util.update_rc_local()
        util.ensure_stellar_data_symlink()
    elif mode == "disable":
        util.remove_rc_local()


if __name__ == '__main__':
    main()
